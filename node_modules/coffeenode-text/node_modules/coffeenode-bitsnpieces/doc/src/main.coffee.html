<!doctype html>

<!-- Documentation generated by [CoffeeDoc](http://github.com/omarkhan/coffeedoc) -->

<html>
<head>
  <title>CoffeeDoc | main.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" media="all" href="../resources/base.css" />
</head>
<body>
  <header>
    <h1>main.coffee</h1>
  </header>
  <div class="container">
    <div class="sidebar column">
      
      
      <h4>Functions</h4>
      <ul class="functionlist">
        
        <li><a href="#this.equals">this.equals</a></li>
        
        <li><a href="#this.format_number">this.format_number</a></li>
        
        <li><a href="#this.escape_regex">this.escape_regex</a></li>
        
        <li><a href="#this.escape_html">this.escape_html</a></li>
        
        <li><a href="#this.get_rnd">this.get_rnd</a></li>
        
        <li><a href="#validate_isa_number">validate_isa_number</a></li>
        
        <li><a href="#this.pluck">this.pluck</a></li>
        
        <li><a href="#this.get_parent_routes">this.get_parent_routes</a></li>
        
        <li><a href="#this.get_V8_CallSite_objects">this.get_V8_CallSite_objects</a></li>
        
        <li><a href="#this.get_caller_info_stack">this.get_caller_info_stack</a></li>
        
        <li><a href="#this.get_caller_stack">this.get_caller_stack</a></li>
        
        <li><a href="#this.get_caller_locators">this.get_caller_locators</a></li>
        
        <li><a href="#this.get_caller_routes">this.get_caller_routes</a></li>
        
        <li><a href="#this.get_filtered_caller_routes">this.get_filtered_caller_routes</a></li>
        
        <li><a href="#this.create_id">this.create_id</a></li>
        
        <li><a href="#this.create_random_id">this.create_random_id</a></li>
        
        <li><a href="#this.get_create_rnd_id">this.get_create_rnd_id</a></li>
        
        <li><a href="#this.id_from_text">this.id_from_text</a></li>
        
        <li><a href="#this.get_app_home">this.get_app_home</a></li>
        
      </ul>
      
    </div>
    <div class="content column">
      
      
      
      <div id="functions">
        <h2>Functions</h2>
        
        <div class="function">
          <div class="header">
            <a id="this.equals"><h3>this.equals(P...)</h3></a>
          </div>
          
          <div>
            <p>TAINT <code>assert.deepEqual</code> is broken as of <a href="https://github.com/joyent/node/issues/7161">https://github.com/joyent/node/issues/7161</a> </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.format_number"><h3>this.format_number(n)</h3></a>
          </div>
          
          <div>
            <p>A simple number formatter. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.escape_regex"><h3>this.escape_regex(text)</h3></a>
          </div>
          
          <div>
            <p> Given a <code>text</code>, return the same with all regular expression metacharacters properly escaped. Escaped
characters are <code>[]{}()*+?-.,\^$|#</code> plus whitespace. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.escape_html"><h3>this.escape_html(text)</h3></a>
          </div>
          
          <div>
            <p> Given a <code>text</code>, return the same with all characters critical in HTML (<code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>) properly
escaped. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_rnd"><h3>this.get_rnd(seed, delta)</h3></a>
          </div>
          
          <div>
            <p> This method returns a simple deterministic pseudo-random number generatorâ€”basically like
<code>Math.random</code>, but (1) very probably with a much worse distribution of results, and (2) with predictable
series of numbers, which is good for some testing scenarios. You may seed this method by passing in a
<code>seed</code> and a <code>delta</code>, both of which must be non-zero numbers; the ensuing series of calls to the returned
method will then always result in the same series of numbers. Here is a usage example that also shows how
to reset the generator:</p>
<pre><code>BAP = <span class="keyword">require</span> <span class="string">'coffeenode-bitsnpieces'</span>
rnd = BAP.get_rnd() <span class="comment"># or, say, `rnd = BAP.get_rnd 123, 0.5`</span>
log BAP.rnd() <span class="keyword">for</span> idx in [ <span class="number">0</span> .. <span class="number">5</span> ]
log()
rnd.reset()
log BAP.rnd() <span class="keyword">for</span> idx in [ <span class="number">0</span> .. <span class="number">5</span> ]
</code></pre><p>Please note that there are no strong guarantees made about the quality of the generated values except the
(1) deterministic repeatability, (2) boundedness, and (3) &#39;apparent randomness&#39;. Do <strong>not</strong> use this for
cryptographic purposes. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="validate_isa_number"><h3>validate_isa_number(x)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.pluck"><h3>this.pluck(x, name, fallback)</h3></a>
          </div>
          
          <div>
            <p> Given some object <code>x</code>, a <code>name</code> and a <code>fallback</code>, return the value of <code>x[ name ]</code>, or, if it does not
exist, <code>fallback</code>. When the method returns, <code>x[ name ]</code> has been deleted. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_parent_routes"><h3>this.get_parent_routes(route)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_V8_CallSite_objects"><h3>this.get_V8_CallSite_objects(delta)</h3></a>
          </div>
          
          <div>
            <p>Save original Error.prepareStackTrace </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_caller_info_stack"><h3>this.get_caller_info_stack(delta)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_caller_stack"><h3>this.get_caller_stack(delta)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_caller_locators"><h3>this.get_caller_locators(delta)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_caller_routes"><h3>this.get_caller_routes(delta)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_filtered_caller_routes"><h3>this.get_filtered_caller_routes(delta)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.create_id"><h3>this.create_id(values, length)</h3></a>
          </div>
          
          <div>
            <p> Given a number of <code>values</code> and a <code>length</code>, return an ID with <code>length</code> hexadecimal digits (<code>[0-9a-f]</code>)
that deterministically depends on the input but can probably not reverse-engeneered to yield the input
values. This is in no way meant to be cryptographically strong, just arbitrary enough so that we have a
convenient method to derive an ID with little chance of overlap given different inputs. <strong>Note</strong> It is
certainly possible to use this method (or <code>id_from_text</code>) to create a hash from a password to be stored in
a DB. Don&#39;t do this. Use <code>bcrypt</code> or similar best-practices for password storage. Again, the intent of
the BITSNPIECES ID utilities is <em>not</em> to be &#39;crypto-safe&#39;; its intent is to give you a tool for generating
repetition-free IDs. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.create_random_id"><h3>this.create_random_id(values, length)</h3></a>
          </div>
          
          <div>
            <p> Like <code>create_id</code>, but with an extra random factor built in that should exclude that two identical
outputs are ever returned for any two identical inputs. Under the assumption that two calls to this
method are highly unlikely two produce an identical pair <code>( 1 * new Date(), Math.random() )</code> (which could
only happen if <code>Math.random()</code> returned the same number again <em>within the same clock millisecond</em>), and
assuming you are using a reasonable value for <code>length</code> (i.e., say, <code>7 &lt; length &lt; 20</code>), you should never
see the same ID twice. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_create_rnd_id"><h3>this.get_create_rnd_id(seed, delta)</h3></a>
          </div>
          
          <div>
            <p> Given an optional <code>seed</code> and <code>delta</code>, returns a function that will create pseudo-random IDs similar to
the ones <code>create_random_id</code> returns; however, the Bits&#39;n&#39;Pieces <code>get_rnd</code> method is used to obtain a
repeatable random number generator so that ID sequences are repeatable. The underlying PRNG is exposed as
<code>fn.rnd</code>, so <code>fn.rnd.reset</code> may be used to start over.</p>
<p><strong>Use Case Example</strong>: The below code demonstrates the interesting properties of the method returned by
<code>get_create_rnd_id</code>: <strong>(1)</strong> we can seed the PRNG with numbers of our choice, so we get a chance to create
IDs that are unlikely to be repeated by other people using the same software, even when later inputs (such
as the email adresses shown here) happen to be the same. <strong>(2)</strong> Calling the ID generator with three
diffferent user-specific inputs, we get three different IDs, as expected. <strong>(3)</strong> Repeating the ID
generation calls with the <em>same</em> arguments will yield <em>different</em> IDs. <strong>(4)</strong> After calling
<code>create_rnd_id.rnd.reset()</code> and feeding <code>create_rnd_id</code> with the <em>same</em> user-specific inputs, we can still
see the identical <em>same</em> IDs generatedâ€”which is great for testing.</p>
<pre><code>create_rnd_id = BAP.get_create_rnd_id <span class="number">1234</span>, <span class="number">87.23</span>

<span class="comment"># three different user IDs:</span>
log create_rnd_id [ <span class="string">'foo@example.com'</span> ], <span class="number">12</span>
log create_rnd_id [ <span class="string">'alice@nosuchname.com'</span> ], <span class="number">12</span>
log create_rnd_id [ <span class="string">'tim@cern.ch'</span> ], <span class="number">12</span>

<span class="comment"># the same repeated, but yielding random other IDs:</span>
log()
log create_rnd_id [ <span class="string">'foo@example.com'</span> ], <span class="number">12</span>
log create_rnd_id [ <span class="string">'alice@nosuchname.com'</span> ], <span class="number">12</span>
log create_rnd_id [ <span class="string">'tim@cern.ch'</span> ], <span class="number">12</span>

<span class="comment"># the same repeated, but yielding the same IDs as in the first run:</span>
log()
create_rnd_id.rnd.reset()
log create_rnd_id [ <span class="string">'foo@example.com'</span> ], <span class="number">12</span>
log create_rnd_id [ <span class="string">'alice@nosuchname.com'</span> ], <span class="number">12</span>
log create_rnd_id [ <span class="string">'tim@cern.ch'</span> ], <span class="number">12</span>
</code></pre><p>The output you should see is</p>
<pre><code>c40f774fce65
9d44f31f9a55
1b26e6e3e736

a0e11f616685
d7242f6935c7
976f26d1b25b

c40f774fce65
9d44f31f9a55
1b26e6e3e736
</code></pre><p>Note the last three IDs exactly match the first three IDs. The upshot of this is that we get reasonably
hard-to-guess, yet on-demand replayable IDs. Apart from weaknesses in the PRNG itself (for which see the
caveats in the description to <code>get_rnd</code>), the obvious way to cheat the system is by making it so that
a given piece of case-specific data is fed into the ID generator as the n-th call a second time. In
theory, we could make it so that each call constributes to the state change inside of <code>create_rnd_id</code>;
a replay would then need to provide all of the case-specific pieces of data a second time, in the right
order. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.id_from_text"><h3>this.id_from_text(text, length)</h3></a>
          </div>
          
          <div>
            <p> Given a <code>text</code> and a <code>length</code>, return an ID with <code>length</code> hexadecimal digits (<code>[0-9a-f]</code>)â€”this is like
<code>create_id</code>, but working on a text rather than a number of arbitrary values. The hash algorithm currently
used is SHA-1, which returns 40 hex digits; it should be good enough for the task at hand and has the
advantage of being widely implemented. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_app_home"><h3>this.get_app_home(routes)</h3></a>
          </div>
          
          <div>
            <p> Return the file system route to the current (likely) application folder. This works by traversing all
the routes in <code>require[ &#39;main&#39; ][ &#39;paths&#39; ]</code> and checking whether one of the <code>node_modules</code> folders
listed there exists and is a folder; the first match is accepted and returned. If no matching existing
route is found, an error is thrown.</p>
<p>NB that the algorithm works even if the CoffeeNode Options module has been symlinked from another location
(rather than &#39;physically&#39; installed) and even if the application main file has been executed from outside
the application folder (i.e. this obviates the need to <code>cd ~/route/to/my/app</code> before doing <code>node ./start</code>
or whateverâ€”you can simply do <code>node ~/route/to/my/app/start</code>), but it does presuppose that (1) there <em>is</em>
a <code>node_modules</code> folder in your app folder; (2) there is <em>no</em> <code>node_modules</code> folder in the subfolder or
any of the intervening levels (if any) that contains your startup file. Most modules that follow the
established NodeJS / npm way of structuring modules should naturally comply with these assumptions. </p>

          </div>
          
        </div>
        
        
          
        
      </div>
      
    </div>
  </div>
</body>
</html>
